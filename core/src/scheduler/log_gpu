resource/Resource.cpp:        case ResourceType::GPU: {
resource/Resource.cpp:            return "GPU";
resource/GpuResource.h:class GpuResource : public Resource {
resource/GpuResource.h:    explicit GpuResource(std::string name, uint64_t device_id, bool enable_executor);
resource/GpuResource.h:    operator<<(std::ostream& out, const GpuResource& resource);
resource/GpuResource.cpp:#include "scheduler/resource/GpuResource.h"
resource/GpuResource.cpp:operator<<(std::ostream& out, const GpuResource& resource) {
resource/GpuResource.cpp:GpuResource::GpuResource(std::string name, uint64_t device_id, bool enable_executor)
resource/GpuResource.cpp:    : Resource(std::move(name), ResourceType::GPU, device_id, enable_executor) {
resource/GpuResource.cpp:GpuResource::Load(TaskPtr task) {
resource/GpuResource.cpp:    task->Load(LoadType::CPU2GPU, device_id_);
resource/GpuResource.cpp:GpuResource::Execute(TaskPtr task) {
resource/Resource.h:    GPU = 2,
selector/FaissIVFPass.cpp:#ifdef MILVUS_GPU_VERSION
selector/FaissIVFPass.cpp:#include "cache/GpuCacheMgr.h"
selector/FaissIVFPass.cpp:    ConfigMgr::GetInstance().Attach("gpu.gpu_search_threshold", this);
selector/FaissIVFPass.cpp:    ConfigMgr::GetInstance().Detach("gpu.gpu_search_threshold", this);
selector/FaissIVFPass.cpp:#ifdef MILVUS_GPU_VERSION
selector/FaissIVFPass.cpp:    gpu_enable_ = config.gpu.enable();
selector/FaissIVFPass.cpp:    threshold_ = config.gpu.gpu_search_threshold();
selector/FaissIVFPass.cpp:    search_gpus_ = ParseGPUDevices(config.gpu.search_devices());
selector/FaissIVFPass.cpp:    if (!gpu_enable_) {
selector/FaissIVFPass.cpp:        LOG_SERVER_DEBUG_ << LogOut("FaissIVFPass: gpu disable, specify cpu to search!");
selector/FaissIVFPass.cpp:        LOG_SERVER_DEBUG_ << LogOut("FaissIVFPass: nq < gpu_search_threshold, specify cpu to search!");
selector/FaissIVFPass.cpp:    } else if (search_task->topk() > server::GPU_QUERY_MAX_TOPK) {
selector/FaissIVFPass.cpp:        LOG_SERVER_DEBUG_ << LogOut("FaissIVFPass: topk > gpu_max_topk_threshold, specify cpu to search!");
selector/FaissIVFPass.cpp:    } else if (search_task->ExtraParam()[knowhere::IndexParams::nprobe].get<int64_t>() > server::GPU_QUERY_MAX_NPROBE) {
selector/FaissIVFPass.cpp:        LOG_SERVER_DEBUG_ << LogOut("FaissIVFPass: nprobe > gpu_max_nprobe_threshold, specify cpu to search!");
selector/FaissIVFPass.cpp:        LOG_SERVER_DEBUG_ << LogOut("FaissIVFPass: nq >= gpu_search_threshold, specify gpu %d to search!",
selector/FaissIVFPass.cpp:                                    search_gpus_[idx_]);
selector/FaissIVFPass.cpp:        res_ptr = ResMgrInst::GetInstance()->GetResource(ResourceType::GPU, search_gpus_[idx_]);
selector/FaissIVFPass.cpp:        idx_ = (idx_ + 1) % search_gpus_.size();
selector/FaissIVFPass.cpp:    threshold_ = config.gpu.gpu_search_threshold();
Scheduler.cpp:#include "cache/GpuCacheMgr.h"
ResourceFactory.h:#include "resource/GpuResource.h"
SchedInst.cpp:#ifdef MILVUS_GPU_VERSION
SchedInst.cpp:    bool enable_gpu = config.gpu.enable();
SchedInst.cpp:    if (enable_gpu) {
SchedInst.cpp:        std::vector<int64_t> gpu_ids = ParseGPUDevices(config.gpu.search_devices());
SchedInst.cpp:        std::vector<int64_t> build_gpu_ids = ParseGPUDevices(config.gpu.build_index_devices());
SchedInst.cpp:        fiu_do_on("load_simple_config_mock", build_gpu_ids.push_back(1));
SchedInst.cpp:        for (auto& build_id : build_gpu_ids) {
SchedInst.cpp:            bool find_gpu_id = false;
SchedInst.cpp:            for (auto& gpu_id : gpu_ids) {
SchedInst.cpp:                if (gpu_id == build_id) {
SchedInst.cpp:                    find_gpu_id = true;
SchedInst.cpp:            if (not find_gpu_id) {
SchedInst.cpp:        for (auto& gpu_id : gpu_ids) {
SchedInst.cpp:            ResMgrInst::GetInstance()->Add(ResourceFactory::Create(std::to_string(gpu_id), "GPU", gpu_id));
SchedInst.cpp:            ResMgrInst::GetInstance()->Connect("cpu", std::to_string(gpu_id), pcie);
SchedInst.cpp:            ResMgrInst::GetInstance()->Add(ResourceFactory::Create(std::to_string(not_find_id), "GPU", not_find_id));
SchedInst.h:#ifdef MILVUS_GPU_VERSION
SchedInst.h:                bool enable_gpu = config.gpu.enable();
SchedInst.h:                if (enable_gpu) {
SchedInst.h:                    std::vector<int64_t> build_gpus = ParseGPUDevices(config.gpu.build_index_devices());
SchedInst.h:                    std::vector<int64_t> search_gpus = ParseGPUDevices(config.gpu.search_devices());
SchedInst.h:                    int64_t gpu_search_threshold = config.gpu.gpu_search_threshold();
SchedInst.h:                    std::string build_msg = "Build index gpu:";
SchedInst.h:                    for (auto build_id : build_gpus) {
SchedInst.h:                        build_msg.append(" gpu" + std::to_string(build_id));
SchedInst.h:                    std::string search_msg = "Search gpu:";
SchedInst.h:                    for (auto search_id : search_gpus) {
SchedInst.h:                        search_msg.append(" gpu" + std::to_string(search_id));
SchedInst.h:                    search_msg.append(". gpu_search_threshold:" + std::to_string(gpu_search_threshold));
Utils.cpp:#ifdef MILVUS_GPU_VERSION
ResourceMgr.h:    GetGpuResources() {
ResourceMgr.h:        return gpu_resources_;
ResourceMgr.h:    GetNumGpuResource() const;
ResourceMgr.h:    std::vector<ResourceWPtr> gpu_resources_;
ResourceFactory.cpp:    } else if (type == "GPU") {
ResourceFactory.cpp:        return std::make_shared<GpuResource>(name, device_id, enable_executor);
task/TestTask.cpp:#include "cache/GpuCacheMgr.h"
task/BuildIndexTask.cpp:        } else if (type == LoadType::CPU2GPU) {
task/BuildIndexTask.cpp:            // no need to copy flat to gpu,
task/BuildIndexTask.cpp:            //            stat = execution_engine_->CopyToGpu(device_id);
task/BuildIndexTask.cpp:            //            type_str = "CPU2GPU:" + std::to_string(device_id);
task/BuildIndexTask.cpp:            gpu_device_id = device_id;
task/BuildIndexTask.cpp:        status = execution_engine_->BuildIndex(gpu_device_id);
task/SearchTask.cpp:        } else if (type == LoadType::CPU2GPU) {
task/SearchTask.cpp:            stat = execution_engine_->CopyToGpu(device_id);
task/SearchTask.cpp:            type_str = "CPU2GPU" + std::to_string(device_id);
task/SearchTask.cpp:        } else if (type == LoadType::GPU2CPU) {
task/SearchTask.cpp:            type_str = "GPU2CPU";
task/BuildIndexTask.h:    // vector field could be build by cpu or gpu, so each task could only handle one field
task/BuildIndexTask.h:    int64_t gpu_device_id = 0;
task/Task.h:    CPU2GPU = 1,
task/Task.h:    GPU2CPU = 2,
ResourceMgr.cpp:        case ResourceType::GPU: {
ResourceMgr.cpp:            gpu_resources_.emplace_back(ResourceWPtr(resource));
ResourceMgr.cpp:    gpu_resources_.clear();
ResourceMgr.cpp:ResourceMgr::GetNumGpuResource() const {
ResourceMgr.cpp:        if (res->type() == ResourceType::GPU) {
ResourceMgr.cpp:        {"number_of_gpu_resource", gpu_resources_.size()},
ResourceMgr.cpp:        // TODO: check one disk-resource, one cpu-resource, zero or more gpu-resource;
ResourceMgr.cpp:        // TODO: check gpu only connect with cpu
